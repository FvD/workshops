{
  "hash": "fe0cb8d8ddd0e2383c6a1b1d1329826b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"5 - Afinando modelos\"\nsubtitle: \"Introducciendo Tidymodels\"\nformat:\n  revealjs: \n    slide-number: true\n    footer: <https://workshops.tidymodels.org>\n    include-before-body: header.html\n    include-after-body: footer-annotations.html\n    theme: [default, tidymodels.scss]\n    width: 1280\n    height: 720\nknitr:\n  opts_chunk: \n    echo: true\n    collapse: true\n    comment: \"#>\"\n    fig.path: \"figures/\"\nexecute:\n  eval: true\n---\n\n\n\n::: {.cell}\n\n:::\n\n\n## Par√°metros de afinamiento\n\nAlgunos valores de los parametros de los modelos o de los preprocesadores no se\npueden estimar directamente desde los datos\n\n. . .\n\nPor ejemplo:\n\n- La profundidad de los √°rboles de decisi√≥n\n- La cantidad de vecinos en un modelo de vecinos K-nearest\n\n## Optimiza los par√°metros de afinamiento\n\n- Prueba valores diferentes para medir la calidad del modelo\n\n. . .\n\n- Encuentra buenos valores para los parametros\n\n. . .\n\n- Una vez los valores de los parametros han sido determinados, el modelo final\nse puede ajustar usando todos los datos en el set de entrenamiento\n\n## Optimiza los par√°metros de afinamiento\n\nHay dos estrategias principales para optimizar:\n\n. . .\n\n-   **Busqueda de cuadr√≠cula (Grid search)** üí† que prueba un set de valores pre-elejidos\n\n-   **Busqueda iterativa** üåÄ que sugiere nuevos valores del parametro para probar\n\n\n## Especificando los parametros de afinamiento\n\nTomemos nueso modelo de bosque aleatorio y tratemos de encontrar el n√∫mero \nm√≠nimo de datos `min_n`\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1|\"}\narbol_espec <- rand_forest(min_n = tune()) %>% \n  set_mode(\"classification\")\n\narbol_flujo <- workflow(propina ~ ., arbol_espec)\narbol_flujo\n#> ‚ïê‚ïê Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n#> Preprocessor: Formula\n#> Model: rand_forest()\n#> \n#> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n#> propina ~ .\n#> \n#> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n#> Random Forest Model Specification (classification)\n#> \n#> Main Arguments:\n#>   min_n = tune()\n#> \n#> Computational engine: ranger\n```\n:::\n\n\n## Try out multiple values\n## Prueba varios valores\n\n`tune_grid()` funciona parecido a `fit_resamples()` pero puede calcular \nmultiples valores del par√°metro:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2|3-4|5|\"}\nset.seed(22)\nrf_res <- tune_grid(\n  arbol_flujo,\n  taxi_plieges,\n  grid = 5\n)\n```\n:::\n\n\n## Compara los resultados\n\nInspecciona los resultados, y selecciona los mejores par√°metros:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshow_best(rf_res)\n#> # A tibble: 5 √ó 7\n#>   min_n .metric .estimator  mean     n std_err .config             \n#>   <int> <chr>   <chr>      <dbl> <int>   <dbl> <chr>               \n#> 1    33 roc_auc binary     0.653    10  0.0159 Preprocessor1_Model1\n#> 2    31 roc_auc binary     0.650    10  0.0167 Preprocessor1_Model3\n#> 3    21 roc_auc binary     0.646    10  0.0165 Preprocessor1_Model4\n#> 4    13 roc_auc binary     0.646    10  0.0143 Preprocessor1_Model5\n#> 5     6 roc_auc binary     0.631    10  0.0140 Preprocessor1_Model2\n\nparametro_mejor <- select_best(rf_res)\nparametro_mejor\n#> # A tibble: 1 √ó 2\n#>   min_n .config             \n#>   <int> <chr>               \n#> 1    33 Preprocessor1_Model1\n```\n:::\n\n\nTambi√©n puedes usar `collect_metrics()` y `autoplot()` \n\n## El ajuste final\n\n\n::: {.cell}\n\n```{.r .cell-code}\narbol_flujo <- finalize_workflow(arbol_flujo, parametro_mejor)\n\najuste_final <- last_fit(arbol_flujo, taxi_separar) \n\ncollect_metrics(ajuste_final)\n#> # A tibble: 2 √ó 4\n#>   .metric  .estimator .estimate .config             \n#>   <chr>    <chr>          <dbl> <chr>               \n#> 1 accuracy binary         0.912 Preprocessor1_Model1\n#> 2 roc_auc  binary         0.636 Preprocessor1_Model1\n```\n:::\n\n\n## Tu turno {transition=\"slide-in\"}\n\n![](images/parsnip-flagger.jpg){.absolute top=\"0\" right=\"0\" width=\"150\" height=\"150\"}\n\n*Modifica tu flujo de modelo para usar por lo menos un par√°metro*\n\n*Usa busqueda de cuadricula para encontrar los mejores parametros*\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"countdown\" id=\"tune-grid\" data-update-every=\"1\" tabindex=\"0\" style=\"right:0;bottom:0;\">\n<div class=\"countdown-controls\"><button class=\"countdown-bump-down\">&minus;</button><button class=\"countdown-bump-up\">&plus;</button></div>\n<code class=\"countdown-time\"><span class=\"countdown-digits minutes\">05</span><span class=\"countdown-digits colon\">:</span><span class=\"countdown-digits seconds\">00</span></code>\n</div>\n```\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../../site_libs/countdown-0.4.0/countdown.css\" rel=\"stylesheet\" />\n<script src=\"../../../site_libs/countdown-0.4.0/countdown.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}